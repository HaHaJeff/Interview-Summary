计算机网络

# 运算层

## 1.为什么还要有传输层

-	IP协议提供的是不可靠的传输协议
-	IP协议只是将数据发送到了目标主机，没有实现由哪个应用程序来接收

## 2.TCP与UDP的区别

[TCP/IP(5)--TCP与UDP](https://blog.csdn.net/shanghairuoxiao/article/details/68927070)

> 1).特征区别

-	a.TCP基于有连接，UDP基于无连接
-	b.TCP能保证可靠传输，UDP不能保证可靠传输
-	c.TCP结构复杂，消耗资源多，建立过程较慢较复杂。UDP结构简单，消耗资源少，建立过程较快
-	d.TCP基于流模式，UDP是数据报模式
-	e.TCP连接只能是点到点（因为要建立连接），而UDP可以一对一，一对多或者多对多，因此广播和多播只能采用UDP数据报的方式
-	f.TCP有确认，重传，拥赛控制机制，UDP在没有建立连接或者对方已经退出的情况下任然会继续发送数据，导致通信流量的浪费

> 2).场景区别

tcp场景：用于实现可靠传输的情况，文件非常重要，对网络拥堵有较高要求的情况。如：电子邮件（SMTP）、远程终端访问(Telnet)、Web（HTTP）、文件传输（FTP）

udp场景：

-	a.用于高速传输和实时性较高的场合（即时通信）
-	b.包总量较少的通信（DNS）
-	c.广播通信
-	例如：ARP、路由选择协议（RIP）、域名服务器（DNS）

流式多媒体或因特网络电话可能使用TCP或UDP

> 3).首部区别

参考[TCP/IP(5)--TCP与UDP](https://blog.csdn.net/shanghairuoxiao/article/details/68927070)

UDP首部长度：8字节

TCP首都长度：20字节

IP首部长度：20字节

## 3.如何实现可靠的UDP 

由上层应用实现消息重传以实现UDP的可靠性。

采用消息重传的时候有两种方式，一种是发送者发起，另一种是接收者发起。

对于发送者发起的方式，一般情况下接收者会发送一个消息包的确认。发送者维护一个计时器并重传那些在某个确定的时间段里没有收到确认的消息包。这一类型的协议容易引起发送者溢出，因为要确认每一个发送的消息包。这种溢出现象被称为发送者（或者ACK）内爆。

对于接收者发起的方式，通信双方的接收者负责错误检测。在这个方式里，序列号被用于检测消息包丢失。当检测到消息包丢失，接收者请求发送者重传消息包。采用这种方法，如果消息包没有到达任何一个接收者，发送者容易因NACK溢出。这会引起发送者的负载过高和过多的重传。这种现像被称为NACK内爆。

## 4.TCP三次握手与四次挥手

[TCP/IP(6)--TCP协议详解](https://blog.csdn.net/shanghairuoxiao/article/details/68927100)

[《计算机网络——自顶向下方法 5.3》---arking](https://github.com/arkingc/note)

![](../../../pics/interview/network/三次握手.png)

![](../../../pics/interview/network/四次挥手.png)

![](../../../pics/interview/network/客户端TCP迁移.png)

![](../../../pics/interview/network/服务器TCP迁移.png)

> 1).握手的目的：获取通信双方的原点序列号，建立连接。

> 2).握手为什么不是2次：

-	a.丢失无法确认
-	b.防止SYN洪泛攻击

> 3).握手为什么不是4次？

如果是4次，那么会是：

-	(1).A发送SYN，SYN + A's Initial sequence number 
-	(2).命名 B's ACK sequence number,B发送ACK
-	(3).B发送SYN，SYN + B's Initial sequence number 
-	(4).命名 A's ACK sequence number，A发送ACK

而这里(2)、(3)可以合并

## 5.经受时延的确认应答和Nagle算法

**经受时延的确认应答**：为了降低确认应答包的数量，TCP提出了经受时延的确认应答。接受端在收到数据后并不立即发送一个应答数据包，而是等待一段时间，如果有新的数据被接受就更新应答号，如果有其他数据要发送就坐上该数据包的顺风车。在系统的内核中维持了一个定时器，一般是200ms如果定时器溢出，即使没有其他数据到达，也发送该应答数据包。

**Nagle算法**：TCP是基于流的传输协议，在Rlogin和Telnet传输中会出现只有一个字节数据的TCP数据包。而一个TCP数据包的首部加上IP首部就有40个字节，很显然发这样的数据包划不来。为了减少这样的数据包，有人提出了Nagle算法。

Nagle算法简单讲就是，等待服务器应答包到达后，再发送下一个数据包。数据在发送端被缓存，如果缓存到达指定大小就将其发送，或者上一个数据的应答包到达，将缓存区一次性全部发送。

Nagle算法是从发送端角度考虑减少了数据包的个数，时延应答从接收端角度考虑减少了数据包的个数。

## 6.TCP可靠传输

《计算机网络 自顶向下》 3.5.4 P163

> 1).超时间隔

发生超时时，超时间隔翻倍，如果收到“上层应用的数据”和“收到ACK”中的任意一个计时器重新启动时，超时间隔由估计值（EstimatedRTT）和估计误差值（DevRtt）计算。

> 2).接收端发生ACK有几种情况

-	(1).期望报文段，且期望段之前的数据都已确认--->延迟ACK
-	(2).期望报文段,且已经有一个延迟ACK--->立即发送单个累积ACK
-	(3).比期望报文段大的失序报文段--->发送冗余ACK，即期待报文段ACK
-	(4).能部分或填充接收间隔的报文段--->立即发送ACK

> 3).TCP可靠传输的机制

```
int NextSeqNum = InitialSeqNum
int SendBase = InitialSequNum

while(true)
{
	switch(event)
	{
		case:"收到上层应用的数据"

			使用NextSeqNum创建TCP报文段；	
			if(计时器未启动)
				启动计时器;
			将报文段传给网络层;
			NextSeqNum = NextSeqNum + 报文段长度;
			break;

		case:"超时"
			重传未确定的最小序号报文段;
			重启计时器;
			break;

		case:"收到ACK报文段，该ACK序号为y"

			if( y > SendBase )
			{
				//累积确认
				SendBase = y;
				if(还有未确认的报文段)
					重启计时器;
			}else
			{
				//收到已经确认过的报文段y的冗余ACK
				冗余ACK数[y]++;
				if( 冗余ACK数[y]==3)
					重传y报文段;
			}
			break;
	}	
}
```

> 4).是GBN还是选择重传

-   发送端：
    -   只有一个定时器
    -   仅维护已发送但未被确认的字节的最小序号（SendBase）和下一个要发送但未被确认的字节的最小序号（NextSeqNum）
    -   有累积确认
-   接收端：
    -   缓存乱序分组，维护一个接收窗口，rcv_base 和窗口长度 N
    -   乱序分组到达时，若分组序号在接收窗口内，返回该分组的 ACK
-   重传时：
    -   发生条件：超时或 3 个冗余 ACK（即总 4 个 ACK）
    -   因为有累积确认，若 1，2，……，N 中只有 n（n<N）未确认，发生超时时，只重传 n
    -   超时加倍，但一旦受到一个 SampleRTT，就将超时设为`TimeoutInterval=EstimatedRTT+4*DevRTT`

TCP 可靠数据传输是 GBN 和选择重传的结合