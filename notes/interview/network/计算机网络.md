计算机网络

# 运算层

## 1.为什么还要有传输层

-	IP协议提供的是不可靠的传输协议
-	IP协议只是将数据发送到了目标主机，没有实现由哪个应用程序来接收

## 2.TCP与UDP的区别

[TCP/IP(5)--TCP与UDP](https://blog.csdn.net/shanghairuoxiao/article/details/68927070)

> 1).特征区别

-	a.TCP基于有连接，UDP基于无连接
-	b.TCP能保证可靠传输，UDP不能保证可靠传输
-	c.TCP结构复杂，消耗资源多，建立过程较慢较复杂。UDP结构简单，消耗资源少，建立过程较快
-	d.TCP基于流模式，UDP是数据报模式
-	e.TCP连接只能是点到点（因为要建立连接），而UDP可以一对一，一对多或者多对多，因此广播和多播只能采用UDP数据报的方式
-	f.TCP有确认，重传，拥赛控制机制，UDP在没有建立连接或者对方已经退出的情况下任然会继续发送数据，导致通信流量的浪费

> 2).场景区别

tcp场景：用于实现可靠传输的情况，文件非常重要，对网络拥堵有较高要求的情况。如：电子邮件（SMTP）、远程终端访问(Telnet)、Web（HTTP）、文件传输（FTP）

udp场景：

-	a.用于高速传输和实时性较高的场合（即时通信）
-	b.包总量较少的通信（DNS）
-	c.广播通信
-	例如：ARP、路由选择协议（RIP）、域名服务器（DNS）

流式多媒体或因特网络电话可能使用TCP或UDP

> 3).首部区别

参考[TCP/IP(5)--TCP与UDP](https://blog.csdn.net/shanghairuoxiao/article/details/68927070)

UDP首部长度：8字节

TCP首都长度：20字节

IP首部长度：20字节

## 3.如何实现可靠的UDP 

由上层应用实现消息重传以实现UDP的可靠性。

采用消息重传的时候有两种方式，一种是发送者发起，另一种是接收者发起。

对于发送者发起的方式，一般情况下接收者会发送一个消息包的确认。发送者维护一个计时器并重传那些在某个确定的时间段里没有收到确认的消息包。这一类型的协议容易引起发送者溢出，因为要确认每一个发送的消息包。这种溢出现象被称为发送者（或者ACK）内爆。

对于接收者发起的方式，通信双方的接收者负责错误检测。在这个方式里，序列号被用于检测消息包丢失。当检测到消息包丢失，接收者请求发送者重传消息包。采用这种方法，如果消息包没有到达任何一个接收者，发送者容易因NACK溢出。这会引起发送者的负载过高和过多的重传。这种现像被称为NACK内爆。

## 4.TCP三次握手与四次挥手

[TCP/IP(6)--TCP协议详解](https://blog.csdn.net/shanghairuoxiao/article/details/68927100)

[《计算机网络——自顶向下方法 5.3》---arking](https://github.com/arkingc/note)

![](../../../pics/interview/network/三次握手.png)

![](../../../pics/interview/network/四次挥手.png)

![](../../../pics/interview/network/客户端TCP迁移.png)

![](../../../pics/interview/network/服务器TCP迁移.png)

> 1).握手的目的：获取通信双方的原点序列号，建立连接。

> 2).握手为什么不是2次：

-	a.丢失无法确认
-	b.防止SYN洪泛攻击

> 3).握手为什么不是4次？

如果是4次，那么会是：

-	(1).A发送SYN，SYN + A's Initial sequence number 
-	(2).命名 B's ACK sequence number,B发送ACK
-	(3).B发送SYN，SYN + B's Initial sequence number 
-	(4).命名 A's ACK sequence number，A发送ACK

而这里(2)、(3)可以合并

> 4).2MSL是什么状态？作用是什么？

[TIME_WAIT状态原理](http://elf8848.iteye.com/blog/1739571)

TIME_WAIT状态。

MSL：Maximum Segment Lifetime，报文最大生存时间。

作用：

主动关闭端：A；被动关闭端B

-	(1).可靠地实现TCP全双工连接的终止:如果最后的ACK丢失，B重发FIN，因此A必须TIME_WAIT，在此期间可以重发ACK
-	(2).允许老的重复分节在网络中消逝:如果第二个FIN发生重发，B也接收到了重发的ACK，则B关闭B的连接。但如果A没有TIME_WAIT，立即A与B又使用相同的端口重建了连接，“新连接”就有可能会收到“旧连接”中A发送的迷失的ACK。而2MSL的TIME_WAIT就是为了让迷失的ACK消逝。

## 5.经受时延的确认应答和Nagle算法

**经受时延的确认应答**：为了降低确认应答包的数量，TCP提出了经受时延的确认应答。接受端在收到数据后并不立即发送一个应答数据包，而是等待一段时间，如果有新的数据被接受就更新应答号，如果有其他数据要发送就坐上该数据包的顺风车。在系统的内核中维持了一个定时器，一般是200ms如果定时器溢出，即使没有其他数据到达，也发送该应答数据包。

**Nagle算法**：TCP是基于流的传输协议，在Rlogin和Telnet传输中会出现只有一个字节数据的TCP数据包。而一个TCP数据包的首部加上IP首部就有40个字节，很显然发这样的数据包划不来。为了减少这样的数据包，有人提出了Nagle算法。

Nagle算法简单讲就是，等待服务器应答包到达后，再发送下一个数据包。数据在发送端被缓存，如果缓存到达指定大小就将其发送，或者上一个数据的应答包到达，将缓存区一次性全部发送。

Nagle算法是从发送端角度考虑减少了数据包的个数，时延应答从接收端角度考虑减少了数据包的个数。

## 6.TCP可靠传输

《计算机网络 自顶向下》 3.5.4 P163

> 1).超时间隔

发生超时时，超时间隔翻倍，如果收到“上层应用的数据”和“收到ACK”中的任意一个计时器重新启动时，超时间隔由估计值（EstimatedRTT）和估计误差值（DevRtt）计算。

> 2).接收端发生ACK有几种情况

-	(1).期望报文段，且期望段之前的数据都已确认--->延迟ACK
-	(2).期望报文段,且已经有一个延迟ACK--->立即发送单个累积ACK
-	(3).比期望报文段大的失序报文段--->发送冗余ACK，即期待报文段ACK
-	(4).能部分或填充接收间隔的报文段--->立即发送ACK

> 3).TCP可靠传输的机制

```
int NextSeqNum = InitialSeqNum
int SendBase = InitialSequNum

while(true)
{
	switch(event)
	{
		case:"收到上层应用的数据"

			使用NextSeqNum创建TCP报文段；	
			if(计时器未启动)
				启动计时器;
			将报文段传给网络层;
			NextSeqNum = NextSeqNum + 报文段长度;
			break;

		case:"超时"
			重传未确定的最小序号报文段;
			重启计时器;
			break;

		case:"收到ACK报文段，该ACK序号为y"

			if( y > SendBase )
			{
				//累积确认
				SendBase = y;
				if(还有未确认的报文段)
					重启计时器;
			}else
			{
				//收到已经确认过的报文段y的冗余ACK，即一共收到了4次时（1次确认收到，3次冗余）就发生快速重传
				冗余ACK数[y]++;
				if( 冗余ACK数[y]==3)
					重传y报文段;
			}
			break;
	}	
}
```

> 4).是GBN还是选择重传

-   发送端：
    -   只有一个定时器
    -   仅维护已发送但未被确认的字节的最小序号（SendBase）和下一个要发送但未被确认的字节的最小序号（NextSeqNum）
    -   有累积确认
-   接收端：
    -   缓存乱序分组，维护一个接收窗口，rcv_base 和窗口长度 N
    -   乱序分组到达时，若分组序号在接收窗口内，返回期待报文序号的ACK（冗余ACK）
-   重传时：
    -   发生条件：超时或 3 个冗余 ACK（即总 4 个 ACK）
    -   因为有累积确认，若 1，2，……，N 中只有 n（n<N）未确认，发生超时时，只重传 n
    -   超时加倍，但一旦受到一个 SampleRTT，就将超时设为`TimeoutInterval=EstimatedRTT+4*DevRTT`

TCP 可靠数据传输是 GBN 和选择重传的结合

## 7.TCP拥塞控制

[TCP/IP(6)--TCP协议详解](https://blog.csdn.net/shanghairuoxiao/article/details/68927100)



> 1).拥塞控制基本概念

(1).判定拥塞出现的条件：出现分组丢失（发生超时或收到重复确认）

-	3次冗余ACK(第一次冗余是第二次收到相同ACK时，所以一共4次)
-	超时

(2).拥塞避免算法中用到了:慢启动、快速重传、快速恢复

(3).拥塞避免算法需要维持两个变量：拥塞窗口和慢启动阀值

(4).LastByteSent - LastByteAcked <= min{CongWin,RcvWindow}

> 3).慢启动

慢启动的增长模式：

-	条件：新的 ACK 到达
-	{ cwnd = cwnd + MSS, dupACKcount = 0, 如果条件允许，传送新报文段 }

> 4).拥塞避免

拥塞避免的增长模式：

-	条件：新的 ACK 到达
-	{ cwnd = cwnd + MSS * ( MSS / cwnd ), dupACKcount = 0, 如果条件允许，传送新报文段 }


> 2).拥塞控制算法：

先采用慢启动算法，到达慢启动阀值后采用拥塞避免算法。

慢启动阶段1：

-	1).通信开始时，发送方的拥塞窗口大小为1MSS。每收到1个ACK确认后，拥塞窗口大小加1MSS。
-	2).出现确认包超时，发送拥塞
-	3).设置“慢启动阈值”，值为前拥塞窗口大小的一半
-	4).拥塞窗口大小设置为1MSS,重新进入慢启动过程

慢启动阶段2：

-	5).由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值后，停止使用慢启动算法，开始采用拥塞避免算法。

拥塞避免阶段：

有可能出现两种情况:

情况一：收到三次重复确认应答--->进入“快速重发”阶段:

-	将“慢启动阈值”设置为当前拥塞窗口大小的一半
-	拥塞窗口大小设置成阈值大小
-	采用拥塞避免算法增加窗口大小，即cwnd = cwnd + MSS * ( MSS / cwnd )

情况二：发生超时

-	“慢启动阈值”设置为当前拥塞窗口的一半
-	拥塞窗口设置为1

//TODO 图！！  鸡哥的图和别人博客的图 分别对照一下上面的过程是否正确。