操作系统

[TOC]

# 进程与线程

参考：[进程与线程](http://blog.csdn.net/shanghairuoxiao/article/details/74012512)

## 1.进程与线程区别？

- 进程是资源分配的基本单位，线程是CPU调度的最小单位
- 进程有独立的地址空间，而同一进程中的线程共享该进程的地址空间

  - 进程拥有：代码段、堆栈段和数据段
  - 线程拥有：寄存器和堆栈（线程栈）
- 线程之间的通信比较方便：

  - 进程通信：进程通信的方式

  - 线程通信：使用同一进程下的共享数据通信。在一个线程中分配的堆在各个线程中均可以使用，在一个线程中打开的文件各个线程均可用，当然指同一进程中的线程
- 多进程比多线程程序要健壮：一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。
- 线程的执行与进程是有区别的：每个独立的进程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制
- linux中进程具有父子关系，形成进程树，但是线程是平等的没有父子关系

进程的四要素

- 程序代码（不一定是一个进程所专有的）
- 用系统堆栈空间
- 进程控制块
- 专用的用户空间

只具备前三条的称为线程。

如果完全没有用户空间称为内核线程。

共享用户空间的称为用户线程。

进程控制块：

![](../../../pics/interview/system/进程控制块.png)

![](../../../pics/interview/system/进程空间.png)

![](../../../pics/interview/system/线程空间.png)

## 2.多进程程序与多线程程序区别，优缺点，使用场合？

- 多进程程序：一个进程崩溃不会影响其他进程，但是进程之间的切换和通信代价较大

- 多线程程序：一个线程崩溃会导致整个进程死掉，其他线程也不能正常工作，但是线程之前数据共享和通信更加方便

- 进程需要开辟独立的地址空间，多进程对资源的消耗很大，而线程则是“轻量级进程”，对资源的消耗更小，对于大并发的情况，只有线程加上IO复用技术才能适应

**场景：**
- 频繁交互数据的、频繁的对同一个对象进行不同的处理--->多线程
- 并发编程、不需要很多数据交互--->多进程

## 3.进程之间的通信

 [**进程间通讯方式**](http://www.cnblogs.com/CheeseZH/p/5264465.html)

[**进程通信**](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/计算机操作系统.md#进程同步)

1).通信需要解决的问题：数据传递、关键部位不会交叉、顺序。

2).进程间通信适用于线程，但是有一个不同的地方，进程间交换数据是在不同的地址空间进行，但是线程是在同一个地址空间进行，只要知道数据的地址，都可以很方便的访问。

3).七种进程间通信方式：

- **信号量**：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据
- **管道( pipe )**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
- **命名管道 (named pipe，FIFO)** ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
- **消息队列( message queue )** ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
- **信号 ( sinal )** ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
- **共享内存( shared memory )** ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 **IPC** 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
- **套接字( socket )** ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信

4).管道（匿名管道）与命名管道的区别:匿名管道只能在具有公共祖先的两个进程间使用

5).**共享文件映射mmap**  //TODO

mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存

6).**常见的信号**

- SIGINT：终止进程，中断进程
- SIGKILL：终止进程，杀死进程，不能被捕获
- SIGTERM：终止进程，软件终止信号，可以被捕获
- SIGSEGV：建立CORE文件，段非法错误
- SIGCHLD：忽略信号，当子进程停止或退出时通知父进程

## 4.进程和线程(POSIX)的系统调用

| 进程原语 | 线程原语       | 描述                       |
| -------- | -------------- | -------------------------- |
| fork     | pthread_create | 创建线程或进程             |
| waitpid  | pthread_join   | 获取线程进程或线程退出状态 |
| getpid   | pthread_self   | 获取进程ID或线程ID         |
| exit     | pthread_exit   | 退出进程或线程             |

## 5.进程状态转换

![](../../../pics/interview/system/进程状态转换.png)

挂起：内存--->外存

激活：外存--->内存

## 6.进程调度算法

[优先级调度](https://github.com/arkingc/note/blob/master/操作系统/操作系统.md#2调度算法)

- 先来先服务（FCFS）
- 轮转（时间片）
- 最短进程优先(SPN)
- 最短剩余时间(SRT)
- 最高响应比(HRRN)
- 反馈法

![](../../../pics/interview/system/进程调度算法.png)

## 7.互斥和同步

- 同步：多个进程按一定顺序执行；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

> 1).互斥的软件支持

**(1).信号量**

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作

- **down**  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

**(2).互斥量**

如果信号量的取值只能为 0 或者 1，那么就成为了  **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

**(3).自旋锁**

自旋锁（Spin lock）是Linux中包含临界区最常见的技术。同一时刻，只有一个线程能获得自旋锁。其它任何企图获得自旋锁的进程将一直进行尝试（忙等），直到获得了该锁

- 普通自旋锁
- 读者-写者自旋锁：允许多个线程同时以只读方式访问同一数据结构，只有当一个线程想要更新时，才会互斥访问

**(4).屏障**

屏障用于保证指令执行的顺序。如，rmb()操作保证了之前和之后的代码都没有任何读操作会穿过屏障.。

对于屏障操作，需要注意2点：

- 1. 屏障和机器指令相关，也就是装载和存储指令（高级语言a=b会产生2个指令）
- 2. 编译方面，屏障操作指示编译器在编译期间不要重新排序指令；处理器方面，屏障操作指示流水线上任何屏障前的指令必须在屏障后的指令开始执行之前提交


> 2).互斥锁（互斥量）与自旋锁的区别

[自旋锁和互斥锁区别](https://blog.csdn.net/sunmenggmail/article/details/8105279)

**(1).互斥锁**

Mutex属于sleep-waiting类型的锁。

例如:

在一个双核的机器上有两个线程(线程A和线程B)，它们分别运行在Core0和 Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞(blocking)，Core0 会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。

**(2).自旋锁**

Spin lock属于busy-waiting类型的锁。

例如：

如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。因此，自旋锁一般用用多核的服务器，自旋锁只有在内核可抢占式或SMP的情况下才真正需要。

**(3)优势劣势互比**

自旋锁的优势：因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。

自旋锁的劣势：

- 自旋锁一直占用CPU，他在未获得锁的情况下，一直运行---自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低
- 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数也可能造成死锁

## 8.死锁

[死锁](https://github.com/arkingc/note/blob/master/操作系统/操作系统.md#2死锁)

>1).死锁的条件

- **(1).互斥**：一次只有一个进程可以使用一个资源
- **(2).占有且等待**：当一个进程等待其他进程时，继续占有已经分配的资源
- **(3).不可抢占**：不能强行抢占进程已占有的资源
- **(4).环路等待**：存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需的一个资源

> 2).处理死锁的方法

- 预防死锁：

  - 间接的死锁预防：防止死锁条件1-3
  - 直接的死锁预防：防止死锁条件4

- 避免死锁

  - 系统安全状态（操作系统 P107）
  - 银行家算法（操作系统P108）：试探地把资源分给请求进程，检查资源分配后系统是否处于安全状态 

- 检测死锁

  - 资源分配图（操作系统P112）：死锁：图不能完全简化

- 解除死锁

  - 剥夺资源
  - 撤销进程

  > 3).哲学家进餐问题

  解决方法：

  - 至多只允许有四位哲学家同时去拿左边筷子
  - 仅当哲学家左右筷子都可用时，才允许拿起筷子进餐
  - 奇数哲学家先拿左筷子，偶数哲学家先拿右筷子

  ​

  ## 9.孤儿进程与僵死进程

  [Linux-孤儿进程与僵尸进程[总结]

  ](https://www.cnblogs.com/JohnABC/p/5734571.html)

   当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

  > 1).孤儿进程怎么产生的

  一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

  > 2).僵尸进程怎么产生的

  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。

  > 3).孤儿进程的危害

  孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，因此孤儿进程并不会有什么危害。

  > 4).僵尸进程的问题及危害

  如果进程不调用wait /waitpid的话， 那么保留的那段信息（进程号、退出状态、运行时间等）就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

  解决方法：通过kill发送SIGTERM或者SIGKILL信号到这个父进程，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。

# 内存管理

[**操作系统对内存管理**](https://blog.csdn.net/shanghairuoxiao/article/details/70256247)

## 1.虚拟内存基本概念

> 1).虚拟内存的作用

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

> 2).虚拟内存的实现

- 操作系统为了管理内存，给每个进程都分配独立的地址空间，对32位的系统而言，这个空间的大小是4GB。这4GB并不是实际的物理内存，实际上并不存在。
- 虚拟地址空间的地址称为逻辑地址，实际物理内存的地址空间称为物理地址。
- 虚拟地址空间被分割成多个大小相同的页面(比如4k为一个页面)，物理地址空间被分割成同样大小的页框。
- 虚拟地址的页面通过一个页表映射物理内存的页框，页表中保存着两者的对应关系。
- 逻辑地址是CPU使用的地址，当进程要访问该进程地址空间里的某个地址时时候，将该地址的值传递给CPU，CPU访问该地址时，会经过MMU（Memory Management Unit，内存管理单元）将逻辑地址转换为物理地址。
- 页表就保存在MMU中，操作系统为每个进程都维护一个页表。
- 程序运行的时候只需要部分数据存在内存中就可以了,只有部分页面和页框有对应值,其余的页表的数据保存在硬盘一块固定的地方（在Linux里叫swap分区）
- 当访问到某个页面在物理内存中没有对应的页框时就会发生**缺页中断**，这时候操作系统就将该页面保存在硬盘中的数据拷贝到物理内存中，并更新页表建立该页面和对应页框之间的映射关系。

![](../../../pics/interview/system/虚拟地址到物理地址的映射.jpg)



- 更详细的关于linux内存管理，可以到[**操作系统对内存管理**](https://blog.csdn.net/shanghairuoxiao/article/details/70256247)看。

![](../../../pics/interview/system/Linux虚拟内存.jpg)

![](../../../pics/interview/system/Linux内存空间结构.png)

> 3).Linux的slab层，VAM

> 4).伙伴算法

> 5).高端内存

## 2.页面置换

>  1).最佳（Optimal）

选择最长时间内不再被访问的页面

>  2).先进先出（FIFO）

选择最先进入的页面

> 3).最近最久未使用（LRU，Least Rencently Used）

选择上次访问到现在时间最长的页面

实现：寄存器或栈

基于寄存器的实现：

为每个在内存中的页面配置一个位移寄存器R=Rn-1,Rn-2,Rn-3,……R2,R1,R0。当进程访问某个页时，该页的寄存器的最高位置位1，所有页的寄存器每隔一段时间向右移动一位。要置换页面时，寄存器值最小的页面就是最近最久未使用的页面。

基于栈的实现：

所有在内存中的页面都在栈中，其中栈顶是刚刚使用的页面，栈顶是最近最久未使用的页面

> 4).时钟（Clock）或最近未使用（NRU, Not Rcently Used）

有两种：简单的和改进的。

简单的实现：内存中的页连城链表，有一个访问位，初始化为1。遍历链表，访问位1则置为0，访问位为0则换出。

改进的实现：有A访问位和M修改位。

淘汰次序（A=0,M=0）、（A=0,M=1）、（A=1,M=0）、（A=1,M=1）

> 5).最少使用（LFU:Least Frequently Used）

选择最近时期最少使用的页面。主要在于这段时间内的使用次数。

## 3.避免内存碎片

> 1).伙伴算法

实现：[Linux 伙伴算法简介](http://www.cnblogs.com/cherishui/p/4246133.html)

基本概念：操作系统 P126 

用于管理物理内存，避免内存碎片--->外部碎片（页框浪费）

> 2).高速缓存Slab

[slab机制](http://www.cnblogs.com/wangzahngjun/p/4977425.html)

用于管理内核分配内存，避免碎片--->内部碎片（页内浪费）

slab分配器是基于对象进行管理的相同类型的对象归为一类。

每当要申请这样一个对象时，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。

![](../../../pics/interview/system/slab主要数据结构.png)

