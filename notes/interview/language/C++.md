C++

<!-- GFM-TOC -->
* [关键字](#关键字)
    * [1. extern关键字作用](#1-extern关键字作用)
    * [2. static关键字作用](#2-static关键字作用)
* [类](#类)
<!-- GFM-TOC -->


# 关键字

## 1.extern关键字作用

-	1).extern声明变量在文件外部定义？
-	2).extern修饰函数？
-	3).extern C的作用？用法？

extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

extern有两个作用：

-	1.当它与"C"一起连用时，如: `extern "C" void fun(int a, int b);`则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的
-	2.当extern不与"C"在一起修饰变量或函数时，如在头文件中: `extern int g_Int;`它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块A(编译单元)中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

**参考**

-	[C/C++中extern关键字详解](https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)

---

## 2.static关键字作用

-	1).static修饰局部变量？
-	2).static全局变量？(限定变量在一个编译单元内，一个编译单元就是指一个cpp和它包含的头文件，这个回答可以结合编译需要经历的几个过程来答)
-	3).static修饰普通函数？
-	4).static修饰成员变量?
-	5).static修饰成员函数？

```
代码区
全局数据区 <---全局变量、静态全局变量、静态局部变量、静态数据成员
堆区 <--- new
栈区 <--- 函数内部的自动变量
```

C++的static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。

**面向过程设计中的static**

-	1).静态全局变量：相较于全局变量：不能被其它文件所用，不会与其他文件变量名冲突。
-	2).静态局部变量：相较于局部变量：函数退出时不会自动销毁，自动初始化
-	3).静态函数：静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用

**面向对象的static关键字（类中的static关键字）** 

-	1).静态数据成员：
	-	静态数据成员在程序中也只有一份拷贝，静态数据成员是该类的所有对象所共有的
	-	不能在类声明中定义
	-＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞  `int Myclass::Sum=0;`
-	2).静态成员函数
	-	与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针	
	-	它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数
	-	出现在类体外的函数定义不能指定关键字static
	-	非静态成员函数可以任意地访问静态成员函数和静态数据成员
	-	静态成员函数不能访问非静态成员函数和非静态数据成员

**参考**

-	[C++中的static关键字的总结](https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html)

---

## 3.volatile关键字作用

-	1).访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。
-	2).一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他

---

## 4.const关键字的作用

**使用**

-	1).定义常量
-	2).指针使用CONST：指针常量、指向常量的指针
-	3).函数中使用CONST
	-	const修饰函数参数
	-	const 修饰函数返回值：一般用于重载操作符
-	4).类相关CONST
	-	const修饰成员变量：它只能在初始化列表中赋值
	-	const修饰成员函数：const成员函数不被允许修改它所在对象的任何一个数据成员；const成员函数能够访问对象的const成员，而其他成员函数不可以；对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。
	-	
	-	/对象指针/对象引用：表示该对象为常量对象，其中的任何成员都不能被修改；任何非const成员函数都不能被调用

**初始化类内部的常量**

-	1).static与const并用，在外部初始化
-	2).初始化列表

**将Const类型转化为非Const类型的方法**

`const_cast <type_id>  (expression) `

-	常量指针被转化成非常量指针，并且仍然指向原来的对象
-	常量引用被转换成非常量引用，并且仍然指向原来的对象
-	常量对象被转换成非常量对象

**参考**

-	[关于C++ const 的全面总结](http://blog.csdn.net/Eric_Jo/article/details/4138548)

---

# 动态内存

## 1.new与malloc区别

-	1).new分配内存按照数据型进行分配，malloc分配内存按照大小分配，以字节为单位；
-	2).new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会
-	3).new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化
-	4).new是一个操作符可以重载，malloc是一个库函数
-	5).malloc分配的内存不够的时候，可以用realloc扩容。扩容原理：如果原先的内存无法改变大小，realloc将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的块上
-	6).new如果分配失败了会抛出bad_malloc的异常（可以用new(nothrow)来不抛出），而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try…catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL；
-	7).new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n；

**TODO**

new和malloc的实现、空闲链表，分配方法(首次适配原则，最佳适配原则，最差适配原则，快速适配原则)。delete和free的实现原理，free为什么直到销毁多大的空间

**参考**

-	[new与malloc的前世今生](http://blog.csdn.net/shanghairuoxiao/article/details/70337890)

---

# 类

## 1.C++多态性与虚函数

> 1).C++多态的实现

多态分为静态多态和动态多态。静态多态（编译时多态）是通过重载和模板技术实现，在编译的时候确定。动态多态（运行时多态）通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

**动态多态实现有几个条件：**

-	(1).虚函数；
-	(2).一个基类的指针或引用,指向派生类的对象；

**调用过程：**

基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。

每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。

虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。

[浅谈C++多态性](http://blog.csdn.net/hackbuteer1/article/details/7475622)

> 2).纯虚函数

纯虚函数：是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 

```c
virtual void funtion()=0 
```

抽象类：包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象

> 3).静态多态与动态多态的区别

静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译期确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。

[C++ 静态多态和动态多态 浅析](http://blog.csdn.net/u013630349/article/details/48009815)

> 4).虚函数的作用

-	用于实现多态
-	封装和抽象，如抽象工厂模式

> 5).虚函数表

编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。

[C++ 虚函数表解析](http://blog.csdn.net/haoel/article/details/1948051/)

---

## 2.构造函数和析构函数

> 1).为什么对于存在虚函数的类中析构函数要定义成虚函数？

-	为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为析构函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。

> 2).析构函数能抛出异常吗

不能。

C++标准指明析构函数不能、也不应该抛出异常。C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。

如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

> 3).构造函数和析构函数中能调用虚函数吗

可以，但是达不到想要的效果，应该尽可能避免在构造函数和析构函数中调用虚函数。

在基类子对象构造期间，编译器直接调用基类版本的虚函数。在子类对象构造期间，编译器直接调用基类虚函数的版本。
	
-	1.构造函数或者析构函数调用虚函数并不会发挥虚函数动态绑定的特性，跟普通函数没区别（会调用基类的版本）
-	2.即使构造函数或者析构函数如果能成功调用虚函数， 程序的运行结果也是不可控的



[构造函数与析构函数中不调用虚函数](http://blog.csdn.net/linpengbin/article/details/51560276)

[【C++】不要在构造函数或析构函数内调用虚函数](https://www.cnblogs.com/vincently/p/4754206.html)

---

# 指针和引用

## 1.指针和引用的区别

-	1).指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问；
-	2).指针可以改变地址，从而改变所指的对象，而引用必须从一而终
-	3).引用在定义的时候必须初始化，而指针则不需要
-	4).指针有指向常量的指针和指针常量，而引用没有常量引用（引用本身就是“常量”的）
-	5).指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全多了，但是比较死板

## 2.指针与数组的关系

不同之处

-	1).数组一旦声明，我们就不能再给数组名赋值，但是我们可以给指针赋值
-	2).用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改
-	3).用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小（单位：字节）

## 3.智能指针 

> 1).实现原理

使用智能指针缘由：

-	a.内存泄漏
-	b.空悬指针(野指针):指向“垃圾”内存
-	c.申请失败时的异常处理：`int *ptr = new(nothrow) int(0);`，异常时返回nullptr

智能指针可以做到：

-	a.智能指针能够帮助我们处理资源泄露问题
-	b.它也能够帮我们处理空悬指针的问题
-	c.它还能够帮我们处理比较隐晦的由异常造成的资源泄露

主要的智能指针类型：`shared_ptr`、`unique_ptr`


[C++智能指针及其简单实现](http://www.cnblogs.com/xiehongfeng100/p/4645555.html)

> 2).如何改变引用计数