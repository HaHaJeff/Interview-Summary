C++

<!-- GFM-TOC -->
* [关键字](#关键字)
    * [1. extern关键字作用](#1-extern关键字作用)
    * [2. static关键字作用](#2-static关键字作用)
* [类](#类)
<!-- GFM-TOC -->


# 关键字

## 1. extern关键字作用

-	1).extern声明变量在文件外部定义？
-	2).extern修饰函数？
-	3).extern C的作用？用法？

extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

extern有两个作用：

-	1.当它与"C"一起连用时，如: `extern "C" void fun(int a, int b);`则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的
-	2.当extern不与"C"在一起修饰变量或函数时，如在头文件中: `extern int g_Int;`它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块A(编译单元)中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

**参考**

-	[C/C++中extern关键字详解](https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)

---

## 2. static关键字作用

-	1).static修饰局部变量？
-	2).static全局变量？(限定变量在一个编译单元内，一个编译单元就是指一个cpp和它包含的头文件，这个回答可以结合编译需要经历的几个过程来答)
-	3).static修饰普通函数？
-	4).static修饰成员变量?
-	5).static修饰成员函数？

```
代码区
全局数据区 <---全局变量、静态全局变量、静态局部变量、静态数据成员
堆区 <--- new
栈区 <--- 函数内部的自动变量
```

C++的static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。

**面向过程设计中的static**

-	1.静态全局变量：相较于全局变量：不能被其它文件所用，不会与其他文件变量名冲突。
-	2.静态局部变量：相较于局部变量：函数退出时不会自动销毁，自动初始化
-	3.静态函数：静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用

**面向对象的static关键字（类中的static关键字）**

-	1.静态数据成员：
	-	静态数据成员在程序中也只有一份拷贝，静态数据成员是该类的所有对象所共有的
	-	不能在类声明中定义
	-＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞  `int Myclass::Sum=0;`
-	2.静态成员函数
	-	与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针	
	-	它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数
	-	出现在类体外的函数定义不能指定关键字static
	-	非静态成员函数可以任意地访问静态成员函数和静态数据成员
	-	静态成员函数不能访问非静态成员函数和非静态数据成员

**参考**

-	[C++中的static关键字的总结](https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html)

---

## 3. volatile关键字作用

-	1.访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。
-	2.一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他

---

## 4. const关键字的作用

**参考**

-	[关于C++ const 的全面总结](http://blog.csdn.net/Eric_Jo/article/details/4138548)


# 类



