C++

<!-- GFM-TOC -->
* [关键字](#关键字)
    * [1. extern关键字作用](#1-extern关键字作用)
    * [2. static关键字作用](#2-static关键字作用)
* [类](#类)
<!-- GFM-TOC -->


# 关键字

## 1. extern关键字作用

-	1).extern声明变量在文件外部定义？
-	2).extern修饰函数？
-	3).extern C的作用？用法？

extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

extern有两个作用：

-	1.当它与"C"一起连用时，如: `extern "C" void fun(int a, int b);`则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的
-	2.当extern不与"C"在一起修饰变量或函数时，如在头文件中: `extern int g_Int;`它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块A(编译单元)中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

**参考**

-	[C/C++中extern关键字详解](https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)

---

## 2. static关键字作用

-	1).static修饰局部变量？
-	2).static全局变量？(限定变量在一个编译单元内，一个编译单元就是指一个cpp和它包含的头文件，这个回答可以结合编译需要经历的几个过程来答)
-	3).static修饰普通函数？
-	4).static修饰成员变量?
-	5).static修饰成员函数？

```
代码区
全局数据区 <---全局变量、静态全局变量、静态局部变量、静态数据成员
堆区 <--- new
栈区 <--- 函数内部的自动变量
```

C++的static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。

**面向过程设计中的static**

-	1).静态全局变量：相较于全局变量：不能被其它文件所用，不会与其他文件变量名冲突。
-	2).静态局部变量：相较于局部变量：函数退出时不会自动销毁，自动初始化
-	3).静态函数：静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用

**面向对象的static关键字（类中的static关键字）** 

-	1).静态数据成员：
	-	静态数据成员在程序中也只有一份拷贝，静态数据成员是该类的所有对象所共有的
	-	不能在类声明中定义
	-＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞  `int Myclass::Sum=0;`
-	2).静态成员函数
	-	与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针	
	-	它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数
	-	出现在类体外的函数定义不能指定关键字static
	-	非静态成员函数可以任意地访问静态成员函数和静态数据成员
	-	静态成员函数不能访问非静态成员函数和非静态数据成员

**参考**

-	[C++中的static关键字的总结](https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html)

---

## 3. volatile关键字作用

-	1).访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为volatile，告诉CPU每次都从内存去读取数据。
-	2).一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他

---

## 4. const关键字的作用

**使用**

-	1).定义常量
-	2).指针使用CONST：指针常量、指向常量的指针
-	3).函数中使用CONST
	-	const修饰函数参数
	-	const 修饰函数返回值：一般用于重载操作符
-	4).类相关CONST
	-	const修饰成员变量：它只能在初始化列表中赋值
	-	const修饰成员函数：const成员函数不被允许修改它所在对象的任何一个数据成员；const成员函数能够访问对象的const成员，而其他成员函数不可以；对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。
	-	const修饰类对象/对象指针/对象引用：示该对象为常量对象，其中的任何成员都不能被修改；任何非const成员函数都不能被调用

**初始化类内部的常量**

-	1).static与const并用，在外部初始化
-	2).初始化列表

**将Const类型转化为非Const类型的方法**

`const_cast <type_id>  (expression) `

-	常量指针被转化成非常量指针，并且仍然指向原来的对象
-	常量引用被转换成非常量引用，并且仍然指向原来的对象
-	常量对象被转换成非常量对象

**参考**

-	[关于C++ const 的全面总结](http://blog.csdn.net/Eric_Jo/article/details/4138548)

# 动态内存

## 1. new与malloc区别

-	1).new分配内存按照数据
-	型进行分配，malloc分配内存按照大小分配，以字节为单位；
-	2).new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会
-	3).new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行
-	类型转化
-	4).new是一个操作符可以重载，malloc是一个库函数
-	5).malloc分配的内存不够的时候，可以用realloc扩容。扩容原理：如果原先的内存无法改变大小，realloc将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的快上
-	6).new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try…catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL；
-	7).new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n；

**TODO**

new和malloc的实现、空闲链表，分配方法(首次适配原则，最佳适配原则，最差适配原则，快速适配原则)。delete和free的实现原理，free为什么直到销毁多大的空间

**参考**

-	[new与malloc的前世今生](http://blog.csdn.net/shanghairuoxiao/article/details/70337890)

# 类

## 1. C++多态性与虚函数

> 1).C++多态的实现

多态分为静态多态和动态多态。静态多态（编译时多态）是通过重载和模板技术实现，在编译的时候确定。动态多态（运行时多态）通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

**动态多态实现有几个条件：**

-	(1).虚函数；
-	(2).一个基类的指针或引用,指向派生类的对象；

**调用过程：**

基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。

每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。

虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。

> 2).纯虚函数

纯虚函数：是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 

```c
virtual void funtion()=0 
```

抽象类：包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象

> 3).静态多态与动态多态的区别

静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译期确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。

参考2

> 4).虚函数的作用

-	用于实现多态
-	封装和抽象，如抽象工厂模式

> 5).虚函数表

编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。

参考3


**参考**

-	1.[浅谈C++多态性](http://blog.csdn.net/hackbuteer1/article/details/7475622)
-	2.[C++ 静态多态和动态多态 浅析](http://blog.csdn.net/u013630349/article/details/48009815)
-	3.[C++ 虚函数表解析](http://blog.csdn.net/haoel/article/details/1948051/)

## 构造函数和析构函数

> 1).为什么对于存在虚函数的类中析构函数要定义成虚函数？

-	为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为析构函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。

> 2).析构函数能抛出异常吗

不能。

C++标准指明析构函数不能、也不应该抛出异常。C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。

> 3).
