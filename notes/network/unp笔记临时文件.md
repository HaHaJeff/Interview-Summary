# 第7章 套接字选项

## 7.1 概述

获取和设置影响套接字的选项的方法

- 1.getsockopt和setsockopt
- 2.fcntl函数：把套接字设置为阻塞式I/O、信号驱动式I/O以及设置套接字属主的POSIX的方法
- 3.ioctl函数

## 7.2 getsockopt和setsockopt

这两个函数仅用于套接字

```c
#include <sys/socket.h>

int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);

int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
```

- sockfd：必须指向一个打开的套接字描述符
- level：指定系统中解释选项的代码
  - 通用套接字代码（`SOL_SOCKET`）
  - 某个特定协议的代码（如IPv4（`IPPROTO_IP`），IPv6、TCP（`IPPROTO_TCP`）或SCTP）
- optval：指向某个变量的指针
  - setsockopt从*optval中取得选项待设置的新值
  - getsockopt把已获取的选项当前值放到*optval中
- optlen：指定*optval的大小
  - setsockopt：值参数
  - getsockopt：值-结果参数
- 返回值： 成功返回0，错误返回-1

对下图的**解释**：

- 1.表中“数据类型”列出了指针optval必须指向的数据类型，后跟花括号的表示一个结构，如`linger{}`表示`struct linger`

- 2.套接字选项粗分为两大基本类型：

  - **标志选项**：启用或禁止某个特性的二元选项，图中“标志”有黑圆点的，此时
    - *optval：一个整数，0表示被禁止，非0表示被启用
  - **值选项**：取回并返回我们可以设置或检查的特定值的选项，图中“标志”没有黑圆点的，此时
    - *optval：用于在用户进程与系统之间传递所指定数据类型的值

  ![](../../pics/network/unp笔记/Pic_7_1_套接字层和IP层的套接字选项汇总.png)

  ![](../../pics/network/unp笔记/Pic_7_2_传输层的套接字选项汇总.png)

  ## 7.4 套接字状态

  以下的套接字选项由TCP已连接套接字从监听套接字继承而来

  - `SO_DEBUG`（开启调试跟踪）
  - `SO_DONTROUTE`（绕过外出路由表查询）
  - `SO_KEEPLIVE`（周期性测试连接是否存活）
  - `SO_LINGER`（若有数据待发送则延迟关闭）
  - `SO_OOBINLINE`（让接收到的带外数据继续再线留存）
  - `SO_RCVBUF`（接收缓冲区大小）
  - `SO_RCVLOWAT`（接收缓冲区低水位标记）
  - `SO_SNDBUF`（发送缓冲区大小）
  - `SO_SNDLOWAT`（发送缓冲区低水位标记）
  - `TCP_MAXSEG`（TCP最大分节大小）
  - `TCP_NODELAY`（禁止Nagle算法）

  ## 7.5 通用套接字选项

  这些选项是协议无关的，不过其中有些选项只能应用到某些特定类型的套接字中。如称`SO_BROADCAST`套接字选项是“通用”的，但它只能用于数据报套接字

  ### 7.5.1 SO_BROADCAST套接字选项

  **限制**：只有**数据报**套接字支持广播，并且必须是支持广播消息的网络上（如以太网）

  **作用**：开启或禁止进程发送广播消息的能力

  由于应用进程在发送广播数据报之前必须设置本套接字选项，因此它能够有效地防止一个进程在其应用程序根本没有设计成可广播时就发送广播数据报

  如果发送数据报的目的地址为广播地址且本套接字选项没有设置，则返回EACCES错误

  ### 7.5.2 SO_DEBUG套接字选项

  **限制**：仅由TCP支持

  **作用**：当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接收的所有分组保留详细跟踪信息。这些信息保留在内核的某个唤醒缓冲区中，并可使用trpt程序进程检查

  ### 7.5.3 SO_DONTROUTE套接字选项

  **作用**：规定外出的分组将绕过底层协议的正常路由机制

  **举例**：如果开启本选项，IPv4情况下外出分组将被定向到适当的本地接口（由目的地址的网络和子网部门确定）。如果这样的本地接口无法由目的地址确定（如目的主机不在一个点对点链路的另一端，也不在一个共享的网络上），则返回ENETUNREACH错误

  **相同效果的做法**：给函数send、sendto、sendmsg使用MSG_DONTROUTE标志，也能在个别的数据报上取得相同效果

  **应用**：路由守护进程（routed和gated）使用本选项绕过路由表（路由表不正确的情况下），以强制将分组从特定接口送出

  ### 7.5.4 SO_ERROR套接字选项

  **背景**:当一个套接字上发生错误时，源自Berkeley的内核中的协议模块将该套接字的名为so_error的变量设为标准的Unix Exxx值中的一个，称为该套接字的待处理错误

  **内核通知进程该错误的方法**：

  - 1.如果进程阻塞在该套接字的select调用上，那么无论是检查该套接字的可读条件还是可写条件，select均返回并设置其中一个或两个条件为“就绪”
  - 2.如果进程使用信号驱动I/O模型，内核给进程或进程组产生一个SIGIO信号

  **进程获取该错误的方法**：使用`getsockopt + SO_ERROR`获取，其中*valopt就是该套接字的待处理错误。获取之后，so_error由内核复位为0

  **read和write发现该错误的过程**：

  - read：
    - 无数据可读时：当进程调用read且没有数据返回时，如果`so_error`为非0，则read返回-1且error被设置为`so_error`的值，随后so_error被复位为0
    - 有数据可读时：如果该套接字上有数据在排队等待读取，read返回数据而不是错误条件
  - write：
    - 如果进程在调用write时so_error为非0，write返回-1，且error被设置为`so_error`的值，随后so_error被复位为0

  ### 7.5.5 SO_KEEPLIVE套接字选项

  **功能**：检测对端主机是否崩溃或变得不可达

  给一个TCP套接字设置**保持存活选项**后，如果2个小时内在该套接字的任何一方上没有数据交换，TCP就自动给对端发送一个**保持存活探测分节**，此时对端必须响应，并可能产生3种情况：

  - 1.**正常**：对端以期望的ACK响应，应用进程得不到通知
  - 2.**对端已经崩溃且已重启**：对端以RST响应，套接字的待处理错误被置为EONNRESET，套接字本身被关闭
  - 3.**无响应**：对端对**保持存活探测分节**没有任何响应，Berkeley的TCP将另外发送8个探测分节，两两相隔75秒，试图得到响应。在第一个探测分节后11分15秒内若没有任何响应则放弃
    - 没有任何响应：套接字的待处理错误设为ETIMEOUT，套接字本身被关闭
    - 收到ICMP错误，返回相应错误，套接字本身被关闭
      - 如，ICMP错误为“host unreachable”（主机不可达），说明对端没有崩溃，只是不可达，待处理错误设为EHOSTUNREACH

  **修改探测定时**：通常为2小时。如果修改该参数会影响到主机上所有开启本选项的套接字。因为是基于整个内核维护这些时间参数的，而不是基于每个套接字维护

  **谁启用**：一般由服务器使用，因为它们花大部分时间阻塞在等待穿越TCP连接的输入上，如果客户主机连接掉线、电源掉电、系统崩溃，服务器进程将永远不知道，并永远等待，这种状态称为**半开连接**。保持存活选项将检测出这些搬开连接并终止它们

  **替代方法**：应用层超时，由应用层进程本身完成

  下图，展示了一个TCP连接的另一端发生某些事情时我们可以采用的各种检测方法的汇总

  ![](../../pics/network/unp笔记/Pic_7_6_检测各种TCP条件的方法.png)

  ### 7.5.6 SO_LINGER套接字选项

  **该选项指定close函数对面向连接的协议如何操作**。默认操作是close函数立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端。SO_LINGER套接字选项使得我们可以改变这个默认设置 

  选项要求在用户进程与内核间传递如下结构：

  ```c
  //定义在头文件<sys/socket.h>
  struct linger{
  	int l_onoff;   /* 0=off（关闭）, nozero=on（开启） */
  	int l_linger;  /* 延滞时间，POSIX指定单位为s */
  };
  ```

  有以下3种情形：

  - 1.**l_onoff为0**：此时l_linger值会被忽略。关闭该选项，默认设置生效，即close立即返回 （**图7.7**） 
  - 2.**l_onoff非0，且l_linger为0**：TCP将终止连接，丢弃保留在套接字发送缓冲区中的任何数据，并发送一个RST给对端，而没有通常的四分组连接终止序列，这么一来避免了TIME_WAIT状态，然而存在以下可能性：在2MSL秒内创建该连接的另一个化身，导致来自刚被终止的连接上的旧的重复分节被不正确地传送到新的化身上 
  - 3.**l_onoff非0，且l_linger非0**：当套接字关闭时，内核将拖延一段时间。如果在套接字发送缓冲区中仍残留有数据，那么进程将投入睡眠，直到：
    - (a)所有数据都已经发送完且均被对方确认；
    -  (b)延滞时间到；（如果套接字被设置为非阻塞，那么将不等待close完成，即使延滞时间非0也是如此） 

  当使用SO_LINGER选项的这个特性时，应用进程检查**close的返回值**是非常重要的，因为如果在数据发送完并被确认前延滞时间到的话，close将返回EWOULDBLOCK错误，且套接字发送缓冲区中的任何残留数据都被丢弃。这种组合可能存在下列几种情况： 

  - **延滞时间合适**：close直到数据和FIN已被服务器主机的TCP确认后才返回（**图7.8**） 
    - 问题：在服务器应用进程读剩余数据之前，服务器主机可能崩溃，并且客户应用进程永远不会知道。因此，close成功返回只是告诉我们先前发送的数据和FIN已由对端TCP确认，而不能告诉我们对端应用进程是否已读取数据 
  - **延滞时间偏低**：在接收到服务器主机的TCP确认前close返回 （**图7.9**） 

  