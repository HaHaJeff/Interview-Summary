[分类参考](https://github.com/arkingc/note/blob/master/数据结构与算法/算法题总结.md)

## 一、数组

#### 单元素查找

- 《剑指3.1》数组中重复的数字 可修改数组（下标比较）
- 《剑指3.2》数组中重复的数字 不可修改数组（二分查找）
  - 《leetcode287》寻找重复数 （二分查找）
  - 《leetcode378》有序矩阵中第K小的元素（1.堆；2.二分查找）
- 《剑指53.1》数字在排序数组中出现的次数（二分查找，找到第一个和最后一个）
- 《剑指53.2》0到n-1中缺失的数字（递增数组，下标比较）
  - 《leetcode268》缺失数字（乱序，求和法、异或法）
- 《剑指53.3》数组中数值和下标相等的元素（排序数组，二分查找，值与下标的比较）
- 《leetcode 162》 寻找峰值（二分查找）
- 《剑指56.1》数组中只出现一次的两个数字（异或，分组后再异或）
- 《剑指56.2》数组中唯一只出现一次的数字 （其他数都出现3次，对各个位求和，能被3整除的位，表示所求数在该位为0，否则为1）
- 《剑指41》 数据流中的中位数（堆、优先级队列）
  - 《Leetcode195》数据流的中位数 
- 《剑指57.1》 和为S的两个数字（递增数组，双指针）
- 《剑指57.2》和为S的连续正数序列（双指针）
- 《剑指39》数组中出现次数超过一半的数字（1.count计数法；2.Partition获取中位数）
- 《剑指40》最小的k个数 （1.数据量少时，Partition；2.海量数据时，堆）
  - 《Leetcode215》数组中的第K个最大元素  （1.数据量少时，Partition；2.海量数据时，堆）
  - 《Leetcode230》二叉搜索树中第K小的元素 （1.递归；2迭代）
  - 《Leetcode347》前K个高频元素（哈希，先使用hashmap统计各个值的频率，然后将元素按频率放入桶中，由桶的高到低输出k个元素）
  - 《leetcode378》有序矩阵中第K小的元素（1.堆；2.二分查找）

#### 连续子数组

- 《剑指42》连续子数组的最大和（动态规划，根据sum是否大于0进行）
- 《leetcode152》乘积最大子序列（维护一个最大值和最小值，同时需要对自身进行一个考虑）

#### 排序组合

- 《剑指38.1》字符串的排序 （全排序 ，递归交换）
  - 《leetcode46》（全排序 ， 递归交换）
  - 《leetcode47》（全排序 ，有重复数， 递归交换和set）
- 《剑指38.2》正方体顶点上放数字（全排序，判断和）
- 《剑指38.3》八皇后（回溯法，行、列、对角线判断）
- 《Leetcode78》子集（1.位运算；2.回溯法）

#### 排序

- 《剑指21》调整数组顺序使奇数位于偶数前面（保持相对顺序：辅助数组；不保持相对顺序：双指针）
- 《Leetcode179》最大数（将数字转换成字符串进行排序）
- 《Leetcode384》打乱数组（随机数）

#### 满足要求的元素对

- 《剑指51》数组中的逆序对（分治法，先把数组分隔成子数组，直到子数组的长度为1，统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序（归并排序））
- 《leetcode315》计算右侧小于当前元素的个数 （二叉搜索树，每个数节点记录左节点数、节点值、相同值数，将数组中元素逆序插入）

#### 二维数组

- 《剑指4》二维数组中的查找（二维数组中 ，左到右递增 ，上到下递增，右上角开始遍历）
- 《剑指29》顺时针打印矩阵（画图分析，分类讨论）
  - 《Leetcode54》螺旋矩阵
- 《Leetcode48》旋转图形 (由(dx,dy)变为(dy,n-1-dx)）
- 《剑指66》构建乘积数组（画图，从上到下，从下到上）

#### 其他

- 《剑指61》扑克牌中的顺子 （排序，计算间隔，注意对子）

# 二、字符串

#### 字符串与数字

- 《剑指20》表示数值的字符串（先将字符串模式划分清楚，再分类讨论）
- 《剑指67》把字符串转换成整数 
  - 《Leetcode8》字符串转整数（鲁棒性，1.首部空格，2.正负号，3.非法值，4.越界）

#### 字符查找

- 《剑指50.1》字符串中第一个只出现一次的字符（两遍扫描，哈希表）
- 《剑指50.2》字符流中第一个只出现一次的字符（使用哈希表的不同值来表示未遇到、遇到1次，遇到多次）

#### 翻转

- 《剑指58.1》翻转单词顺序（“I am a student.” 变为“student. a am I” ，先反转整个字符串，再对每个单词再翻转）
- 《剑指58.2》左旋转字符串（类似与位左移回卷操作，“abcXYZdef”变为“XYZdefabc”，先反转所有字符串，变为“fedZYXcba”，再根据某个分割点进行分别反转）
- 《Leetcode334》反转字符串（简单的前后反转，使用双指针）

#### 删除替代

- 《剑指5》替换空格（先计算空格数，然后从后向前开始替换）

#### 异位词

- 《Leetcode49》字母异位词分组（排序，哈希；将每个字符串排序后的字符串作为key，排序前的字符串作为value。这里涉及一个计数排序）
- 《Leetcode242》有效的字母异位词（1.排序；2.哈希）

#### 单词查找

- 《Leetcode208》实现前缀树（字典树，哈希表）
- 《Leetcode79》单词搜索（单个单词查找，DFS）
- 《Leetcode212》单词搜索 II（多个单词查找，使用多个单词建立字典树，然后再DFS，字典树+DFS）

#### 字符串转换

- 《Leetcode91》解码方法（递归，可分解为`1~9`的，可以分解成`10~26`的）
- 《Leetcode127》单词接龙（哈希+BFS，将字符串中的每一个字符替换成[a-z]，并查询字典）

#### 子串与子序列

- 《Leetcode28》实现strStr()（1.KMP？；2.使用substr实现）
- 《Leetcode3》无重复字符的最长子串（考虑三种情况：1.字符未出现过；2.1.字符出现过，但不在目前计算范围之内；2.2.字符出现过，在目前计算范围之内）
  - 《剑指48》最长不含重复字符的子字符串
- 《Leetcode395》至少有K个重复字符的最长子串（哈希+递归，哈希统计所有字符出现次数，寻找第一个次数少于k的字符，如果找不到，则说明本字符串是符合要求的，如果找到，以找到的少于k的字符为分隔，递归调用）
- 《Leetcode5》最长回文子串（1.动态规划？；2.中间向两边扩散，注意偶数回文和奇数回文的处理）
- 《Leetcode125》验证回文串（双指针）

#### 字符串拆分

- 《Leetcode131》分割回文串（递归，将str[0,i)判断是否为回文，如果是则加入路径，递归判断str[i,end)，如果都是，将路径加入结果）
- 《Leetcode139》单词拆分（将单词拆分为词典中的词，求是否能拆分，1.记忆递归，记忆某次分隔是否成功；2.动态规划，dp[i]表示从str[i,end]是否能被成功拆分）
- 《Leetcode140》单词拆分II（将单词拆分成词典中的词，返回所有可能的情况，1.记忆递归，将单词拆分成左右两部分，右边部分在词典中可查，左边部分递归调用获得一个vector，然后将左右组合在一起）

#### 字符串匹配

- 《Leetcode10》正则表达式（动态规划）
- 《Leetcode44》通配符匹配（动态规划）

#### 公共子串和公共子序列

- 《LintCode77》最长公共子序列（LCS，《王道》10.2.1，序列可间隔出现，动态规划）
- 《LintCode79》最长公共子串（字符应连续出现，《王道》10.2.1，动态规划）
- 《LintCode119》编辑距离（经过几次操作后，两个字符相等，《王道》10.2.2，动态规划） 
- 《Leetcode14》最长公共前缀（1.垂直扫描；2.分治：将字符串分为2组，求出第一组的前缀和第二组的前缀，然后求两个前缀字符串的公共前缀）

# 三、链表

#### 遍历

- 《剑指6》从尾到头打印链表（1.栈；2.递归）
- 《Leetcode234》回文链表（中部翻转链表）
- 《剑指22.1》链表中倒数第k个节点（双指针，快指针先走k-1步）
- 《剑指22.2》链表的中间节点（快慢指针，快指针一次走两步，慢指针一次走一步）
- 《Leetcode19》删除链表的倒数第N个节点（双指针，快指针先走N步，则慢指针可以指向要删除元素的前一个指针。需要注意特殊情况：空链、只有一个节点、头节点、尾节点）
- 《Leetcode141》环形链表（快慢指针相遇）
- 《剑指23》链表中的入口节点（双指针，1.判断是否有环；2.获得环的个数n；3.从链表头开始，一个指针先走n，然后一起走，相遇的地方就是环的入口）

#### 节点删除

- 《剑指18.1》在O(1)时间删除链表结点（给定某个节点的指针，要求删除。覆盖法，特殊情况：1.删除尾节点；2.只有一个节点）
- 《剑指18.2》删除链表中重复的节点
  - 《Leetcode83》删除排序链表中的重复元素（每个节点只能出现一次，不会删除表头）
  - 《Leetcode82》删除排序链表中的重复元素II（出现重复的节点都要删除。因为可能删除表头，因此生成一个新的表头节点进行辅助）
- 《Leetcode203》删除链表中的节点（删除链表中所有值等于某个值的节点。因为可能删除表头，因此生成一个新的表头节点进行辅助）
- 《剑指62》圆圈中最后剩下的数字（使用环状链表解决）
- 《腾讯面试题》实现双向链表节点删除函数（考虑1.只有一个节点；2.删除头节点；3.删除尾节点；4.删除中间节点）

#### 单链表处理

- 《剑指24》反转链表（1.迭代；2.递归）
- 《剑指35》复杂链表的复制（1.在每个节点后生成并连接一个相同节点；2.设置随机节点；3.将新旧节点断开）
  - 《Leetcode138》复制带随机指针的链表
- 《Leetcode24》两两交换链表中的节点（由于可能改变表头，因此使用一个辅助表头。同时注意链表的题目应该先画图解决）
- 《Leetcode148》排序链表（归并排序的思想：先两两归并，再四四归并……）
- 《Leetcode328》奇偶链表（1.将链表拆分为奇偶链表；2.将偶链放于奇链之后）

#### 多链表处理

- 《Leetcode2》两数相加（注意进位问题,特别是最高位的进位）
- 《剑指25》合并两个有序链表（1.迭代；2.递归。使用辅助表头）
- 《Leetcode23》合并K个排序链表（优先级队列+归并。优先级队列的元素为`pair<int,int>`，分别表示为值、链表的下标）
- 《剑指52》两个链表的第一个公共节点（1.栈；2.快慢指针）

# 四、树

#### 遍历

- 《剑指7》重建二叉树（前序、中序、递归）
- 《剑指8》二叉树的下一个节点（1.如有右孩，则为右孩最左；2.如无右孩：2.1.是其父节点的左孩，则为其父；2.2不断递归向上，找到为其父的左孩）
- 《剑指26》树的子结构（首先找到A与B相同值的节点，再根据此节点进行是否是子树的递归判断）
- 《剑指37》序列化二叉树
  - 《Leetcode297》二叉树的序列化与反序列化（1.使用字符串传递，istringstream和ostringstream。2.使用二进制，优点是高效率和低存储）
- 《Leetcode94》二叉树的中序遍历（1.递归；2.栈：如果有左孩，则不断压栈，直到无左孩，出栈并输出值，如果出栈节点有右孩，则对右孩及其右孩的左孩不断压栈）
- 《Leetcode98》验证二叉搜索树（1.限定值范围。2.中序遍历）
- 《剑指33》二叉搜索树的后序遍历序列（根据nums[end]划分数组，然后判断左右子数组是否符合二叉搜索树的特性，然后再对左右子数组递归）
- 《剑指36》二叉搜索树与双向链表（使用递归函数，先将左孩子处理成双向链表，并返回双向链表的最后一个节点，再用最后一个节点与父节点相连，再处理右孩子）
- 《Leetcode109》有序链表转换二叉搜索树（使用快慢指针将获取中位节点，拆成两个链分别称为左右子树，注意空链、只有一个节点、只有两个节点、三个及三个节点以上的情况）
- 《Leetcode108》将有序数组转换为二叉搜索树（根据中位数划分左右子数组，分别称为左右子树）
- 《剑指54》二叉搜索树的第k大节点（中序遍历）
- 《Leetcode116》填充同一层的兄弟节点（1.队列；2.首先处理左孩子到右孩子的next链接，再处理本节点的右孩子与本节点的next的左孩子的next链接，画图分析）
- 《剑指32.1》不分行从上到下打印二叉树（BFS、队列）
- 《剑指32.2》分行从上到下打印二叉树（BFS、队列，对每一行做一个元素统计）
- 《剑指32.3》之字形打印二叉树（使用两个栈，奇偶层交替使用）

#### 对称二叉树









---

- 《Leetcode55》跳跃游戏（判断是否能跳跃到数组的最右端，贪心算法，使用一个reach值）
- 《Leetcode45》跳跃游戏II（计算跳跃到数组最右端的最少跳跃次数，1.动态规划；2.贪心算法，考虑两步跳跃的范围）