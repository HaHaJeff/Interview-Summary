[分类参考](https://github.com/arkingc/note/blob/master/数据结构与算法/算法题总结.md)

## 一、数组

#### 单元素查找

- 《剑指3.1》数组中重复的数字 可修改数组（下标比较）
- 《剑指3.2》数组中重复的数字 不可修改数组（二分查找）
  - 《leetcode287》寻找重复数 （二分查找）
  - 《leetcode378》有序矩阵中第K小的元素（1.堆；2.二分查找）
- 《剑指53.1》数字在排序数组中出现的次数（二分查找，找到第一个和最后一个）
- 《剑指53.2》0到n-1中缺失的数字（递增数组，下标比较+二分查找）
  - 《leetcode268》缺失数字（乱序，求和法、异或法）
- 《剑指53.3》数组中数值和下标相等的元素（排序数组，二分查找，值与下标的比较）
- 《leetcode 162》 寻找峰值（二分查找）
- 《剑指56.1》数组中只出现一次的两个数字（异或，根据异或分组后再异或）
- 《剑指56.2》数组中唯一只出现一次的数字 （其他数都出现3次，对各个位求和，能被3整除的位，表示所求数在该位为0，否则为1）
- 《剑指41》 数据流中的中位数（堆、优先级队列）
  - 《Leetcode195》数据流的中位数 
- 《剑指57.1》 和为S的两个数字（递增数组，双指针）
- 《剑指57.2》和为S的连续正数序列（双指针）
- 《剑指39》数组中出现次数超过一半的数字（1.count计数法；2.Partition获取中位数）
- 《剑指40》最小的k个数 （1.数据量少时，Partition；2.海量数据时，堆）
  - 《Leetcode215》数组中的第K个最大元素  （1.数据量少时，Partition；2.海量数据时，堆）
  - 《Leetcode230》二叉搜索树中第K小的元素 （1.递归；2迭代）
  - 《Leetcode347》前K个高频元素（哈希，先使用hashmap统计各个值的频率，然后将元素按频率放入桶中，由桶的高到低输出k个元素）
  - 《leetcode378》有序矩阵中第K小的元素（1.堆；2.二分查找）

#### 连续子数组

- 《剑指42》连续子数组的最大和（动态规划，根据sum是否大于0进行）
- 《leetcode152》乘积最大子序列（维护一个最大值和最小值，同时需要对自身进行一个考虑）

#### 排序组合

- 《剑指38.1》字符串的排序 （全排序 ，递归交换）
  - 《leetcode46》（全排序 ， 递归交换）
  - 《leetcode47》（全排序 ，有重复数， 递归交换和set）
- 《剑指38.2》正方体顶点上放数字（全排序，判断和）
- 《剑指38.3》八皇后（回溯法，行、列、对角线判断）
- 《Leetcode78》子集（1.位运算；2.回溯法）

#### 排序

- 《剑指21》调整数组顺序使奇数位于偶数前面（保持相对顺序：辅助数组；不保持相对顺序：双指针）
- 《Leetcode179》最大数（将数字转换成字符串进行排序）
- 《Leetcode384》打乱数组（随机数）

#### 满足要求的元素对

- 《剑指51》数组中的逆序对（分治法，先把数组分隔成子数组，直到子数组的长度为1，统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序（归并排序））
- 《leetcode315》计算右侧小于当前元素的个数 （二叉搜索树，每个数节点记录左节点数、节点值、相同值数，将数组中元素逆序插入）

#### 二维数组

- 《剑指4》二维数组中的查找（二维数组中 ，左到右递增 ，上到下递增，右上角开始遍历）
- 《剑指29》顺时针打印矩阵（画图分析，分类讨论）
  - 《Leetcode54》螺旋矩阵
- 《Leetcode48》旋转图形 (由(dx,dy)变为(dy,n-1-dx)）
- 《剑指66》构建乘积数组（画图，从上到下，从下到上）

#### 其他

- 《剑指61》扑克牌中的顺子 （排序，计算间隔，注意对子）

# 二、字符串

#### 字符串与数字

- 《剑指20》表示数值的字符串（先将字符串模式划分清楚，再分类讨论）
- 《剑指67》把字符串转换成整数 
  - 《Leetcode8》字符串转整数（鲁棒性，1.首部空格，2.正负号，3.非法值，4.越界）

#### 字符查找

- 《剑指50.1》字符串中第一个只出现一次的字符（两遍扫描，哈希表）
- 《剑指50.2》字符流中第一个只出现一次的字符（使用哈希表的不同值来表示：未遇到-1、遇到1次，记录下标，遇到多次-2）

#### 翻转

- 《剑指58.1》翻转单词顺序（“I am a student.” 变为“student. a am I” ，先反转整个字符串，再对每个单词再翻转）
- 《剑指58.2》左旋转字符串（类似与位左移回卷操作，“abcXYZdef”变为“XYZdefabc”，先反转所有字符串，变为“fedZYXcba”，再根据某个分割点进行分别反转）
- 《Leetcode334》反转字符串（简单的前后反转，使用双指针）

#### 删除替代

- 《剑指5》替换空格（先计算空格数，然后从后向前开始替换）

#### 异位词

- 《Leetcode49》字母异位词分组（排序，哈希；将每个字符串排序后的字符串作为key，排序前的字符串作为value。这里涉及一个计数排序）
- 《Leetcode242》有效的字母异位词（1.排序；2.哈希）

#### 单词查找

- 《Leetcode208》实现前缀树（字典树，哈希表）
- 《Leetcode79》单词搜索（单个单词查找，DFS）
- 《Leetcode212》单词搜索 II（多个单词查找，使用多个单词建立字典树，然后再DFS，字典树+DFS）

#### 字符串转换

- 《Leetcode91》解码方法（递归，可分解为`1~9`的，可以分解成`10~26`的）
- 《Leetcode127》单词接龙（哈希+BFS，将字符串中的每一个字符替换成[a-z]，并查询字典）

#### 子串与子序列

- 《Leetcode28》实现strStr()（1.KMP？；2.使用substr实现）
- 《Leetcode3》无重复字符的最长子串（考虑三种情况：1.字符未出现过；2.1.字符出现过，但不在目前计算范围之内；2.2.字符出现过，在目前计算范围之内）
  - 《剑指48》最长不含重复字符的子字符串
- 《Leetcode395》至少有K个重复字符的最长子串（哈希+递归，哈希统计所有字符出现次数，寻找第一个次数少于k的字符，如果找不到，则说明本字符串是符合要求的，如果找到，以找到的少于k的字符为分隔，递归调用）
- 《Leetcode5》最长回文子串（1.动态规划？；2.中间向两边扩散，注意偶数回文和奇数回文的处理）
- 《Leetcode125》验证回文串（双指针）

#### 字符串拆分

- 《Leetcode131》分割回文串（递归，将str[0,i)判断是否为回文，如果是则加入路径，递归判断str[i,end)，如果都是，将路径加入结果）
- 《Leetcode139》单词拆分（将单词拆分为词典中的词，求是否能拆分，1.记忆递归，记忆某次分隔是否成功；2.动态规划，dp[i]表示从str[i,end]是否能被成功拆分）
- 《Leetcode140》单词拆分II（将单词拆分成词典中的词，返回所有可能的情况，1.记忆递归，将单词拆分成左右两部分，右边部分在词典中可查，左边部分递归调用获得一个vector，然后将左右组合在一起）

#### 字符串匹配

- 《Leetcode10》正则表达式（动态规划）
- 《Leetcode44》通配符匹配（动态规划）

#### 公共子串和公共子序列

- 《LintCode77》最长公共子序列（LCS，《王道》10.2.1，序列可间隔出现，动态规划）
- 《LintCode79》最长公共子串（字符应连续出现，《王道》10.2.1，动态规划）
- 《LintCode119》编辑距离（经过几次操作后，两个字符相等，《王道》10.2.2，动态规划） 
- 《Leetcode14》最长公共前缀（1.垂直扫描；2.分治：将字符串分为2组，求出第一组的前缀和第二组的前缀，然后求两个前缀字符串的公共前缀）
- 《笔试题2》最长重复字符串（后缀字符串数组，先生成后缀字符串数组，再排序，再相邻两两比较）

# 三、链表

#### 遍历

- 《剑指6》从尾到头打印链表（1.栈；2.递归）
- 《Leetcode234》回文链表（中部翻转链表）
- 《剑指22.1》链表中倒数第k个节点（双指针，快指针先走k-1步）
- 《剑指22.2》链表的中间节点（快慢指针，快指针一次走两步，慢指针一次走一步）
- 《Leetcode19》删除链表的倒数第N个节点（双指针，快指针先走N步，则慢指针可以指向要删除元素的前一个指针。需要注意特殊情况：空链、只有一个节点、头节点、尾节点）
- 《Leetcode141》环形链表（快慢指针相遇）
- 《剑指23》链表中的入口节点（双指针，1.判断是否有环；2.获得环的个数n；3.从链表头开始，一个指针先走n，然后一起走，相遇的地方就是环的入口）

#### 节点删除

- 《剑指18.1》在O(1)时间删除链表结点（给定某个节点的指针，要求删除。覆盖法，特殊情况：1.删除尾节点；2.只有一个节点）
- 《剑指18.2》删除链表中重复的节点
  - 《Leetcode83》删除排序链表中的重复元素（每个节点只能出现一次，不会删除表头）
  - 《Leetcode82》删除排序链表中的重复元素II（出现重复的节点都要删除。因为可能删除表头，因此生成一个新的表头节点进行辅助）
- 《Leetcode203》删除链表中的节点（删除链表中所有值等于某个值的节点。因为可能删除表头，因此生成一个新的表头节点进行辅助）
- 《剑指62》圆圈中最后剩下的数字（使用环状链表解决）
- 《腾讯面试题》实现双向链表节点删除函数（考虑1.只有一个节点；2.删除头节点；3.删除尾节点；4.删除中间节点）

#### 单链表处理

- 《剑指24》反转链表（1.迭代；2.递归）
- 《剑指35》复杂链表的复制（1.在每个节点后生成并连接一个相同节点；2.设置随机节点；3.将新旧节点断开）
  - 《Leetcode138》复制带随机指针的链表
- 《Leetcode24》两两交换链表中的节点（由于可能改变表头，因此使用一个辅助表头。同时注意链表的题目应该先画图解决）
- 《Leetcode148》排序链表（归并排序的思想：先两两归并，再四四归并……）
- 《Leetcode328》奇偶链表（1.将链表拆分为奇偶链表；2.将偶链放于奇链之后）

#### 多链表处理

- 《Leetcode2》两数相加（注意进位问题,特别是最高位的进位）
- 《剑指25》合并两个有序链表（1.迭代；2.递归。使用辅助表头）
- 《Leetcode23》合并K个排序链表（优先级队列+归并。优先级队列的元素为`pair<int,int>`，分别表示为值、链表的下标）
- 《剑指52》两个链表的第一个公共节点（1.栈；2.快慢指针）

# 四、树

#### 遍历

- 《剑指7》重建二叉树（前序、中序、递归）
- 《剑指8》二叉树的下一个节点（1.如有右孩，则为右孩最左；2.如无右孩：2.1.是其父节点的左孩，则为其父；2.2不断递归向上，找到为其父的左孩）
- 《剑指26》树的子结构（首先找到A与B相同值的节点，再根据此节点进行是否是子树的递归判断）
- 《剑指37》序列化二叉树
  - 《Leetcode297》二叉树的序列化与反序列化（1.使用字符串传递，istringstream和ostringstream。2.使用二进制，优点是高效率和低存储）
- 《Leetcode94》二叉树的中序遍历（1.递归；2.栈：如果有左孩，则不断压栈，直到无左孩，出栈并输出值，如果出栈节点有右孩，则对右孩及其右孩的左孩不断压栈）
- 《Leetcode98》验证二叉搜索树（1.限定值范围。2.中序遍历）
- 《剑指33》二叉搜索树的后序遍历序列（根据nums[end]划分数组，然后判断左右子数组是否符合二叉搜索树的特性，然后再对左右子数组递归）
- 《剑指36》二叉搜索树与双向链表（使用递归函数，先将左孩子处理成双向链表，并返回双向链表的最后一个节点，再用最后一个节点与父节点相连，再处理右孩子）
- 《Leetcode109》有序链表转换二叉搜索树（使用快慢指针将获取中位节点，拆成两个链分别称为左右子树，注意空链、只有一个节点、只有两个节点、三个及三个节点以上的情况）
- 《Leetcode108》将有序数组转换为二叉搜索树（根据中位数划分左右子数组，分别称为左右子树）
- 《剑指54》二叉搜索树的第k大节点（中序遍历）
- 《Leetcode116》填充同一层的兄弟节点（1.队列；2.首先处理左孩子到右孩子的next链接，再处理本节点的右孩子与本节点的next的左孩子的next链接，画图分析）
- 《剑指32.1》不分行从上到下打印二叉树（BFS、队列）
- 《剑指32.2》分行从上到下打印二叉树（BFS、队列，对每一行做一个元素统计）
- 《剑指32.3》之字形打印二叉树（使用两个栈，奇偶层交替使用）

#### 对称二叉树

- 《剑指27》二叉树的镜像（1.递归；2.栈）
- 《剑指28》（1.递归；2.双栈。false的情况为：树1为空，树2不为空；树1不为空，树2为空；树1树2值不等。对于栈，需要将nullptr也压入）

#### 路径

- 《剑指34》二叉树中和为某一值的路径（递归，注意找到有效结果后不要立刻返回，还需要将当前路径的当前值去掉）
- 《剑指68》树中两个节点的最低公共祖先（1.二叉搜索树：值比较；2.普通树，有子到父指针：快慢指针；3.其他情况：递归找到路径做出链，再快慢指针）
- 《Leetcode124》二叉树中的最大路径和（递归。孩子节点为负值，则不取。计算结果时，计算root+left+right，返回结果时（表示需要回到父节点，此时不可能包含左右孩子），返回man(left,right)+root）
- 《Leetcode863》二叉树中所有距离为 K 的结点（1.将树转为无向图；2.从target开始广度优先遍历）

#### 深度

- 《剑指55.1》二叉树的深度（递归）
- 《剑指55.2》平衡二叉树（1.使用55.1的递归，计算左右子树的高度，差不超过1；2.后序递归遍历，可避免子树的重复计算）

#### 公共祖先

- 《剑指68》树中两个节点的最低公共祖先

# 五、栈和队列

#### 设计

- 《剑指9.1》用两个栈实现队列（栈1负责入队操作，栈2负责出队操作，若栈2无元素，则将栈1元素弹出并压入栈2）
- 《剑指9.2》用两个队列实现栈（插入：元素插入包含元素的队列 。删除：将包含n个元素的队列前n-1个元素移入另一个空队列，取出第n个元素）
- 《剑指30》包含min函数的栈
  - 《Leetcode155》最小栈（双栈，栈1存正常元素，栈2存最小元素，栈2入栈时，对比入栈元素与栈顶元素，将较小的入栈，注意空栈时则直接压入）
- 《剑指59.1》滑动窗口的最大值
  - 《Leetcode239》滑动窗口最大值（单调队列：入队时，从队尾入，有小于自身的值都弹出；出队时，从队首出。需要注意滑出窗口的数要记得弹出）
- 《剑指59.2》包含max函数的队列（与滑动窗口类似，但需要一个数据结构来保存值和下标，当pop时需要对照下标进行弹出）

#### 其他

- 《剑指31》栈的压入弹出序列（使用栈来模拟，如果栈顶元素不等于出栈指针元素，则不断入栈；如果相等则出栈，并出栈指针后移）
- 《Leetcode20》有效的括号（栈+哈希map，栈为空或不匹配则入栈，匹配则出栈）

# 六、数学

#### 斐波那契数列

- 《剑指10.1》斐波那契数列（1.递归；2.迭代；f(n) = f(n-1) + f(n-2)）
- 《剑指10.2》青蛙跳台阶（斐波那契数列的应用）
- 《剑指10.3》变态青蛙跳台阶（f(n) = f(n-1)+f(n-2)+...f(1)+1）
- 《剑指10.4》矩形覆盖（仍然是斐波那契数列的应用）

#### 特殊

- 《剑指49》丑数（使用一个数组vector存放排序的丑数。每产生一个新的丑数，肯定是现有数组中的数乘以2、3、5而来的值 ，因此使用三个指针，分别指向三个位置，这三个位置分别乘以2、3、5的某一个值，将是下一个产生的最小丑数）
- 《Leetcode36》有效的数读（使用哈希，遍历每个数时，对每行、每列、每宫进行记录）
- 《Leetcode204》计数质数（质数的定义：一个大于1的自然数,除了1和它本身外,不能被其他自然数整除（最小质数为2）。使用数组记录某个数m是否由数i*j得来的，因此2开始遍历，碰到一个未被记录的数，则将结果加加）
- 《Leetcode279》完全平方数（动态规划，F(n) = min{F(n),F(n-1)+1,F(n-4)+1,...,F(n-q*q)+1} ）

#### 进制

- 《剑指15》二进制中1的个数 （`(n-1) & n` ）
- 《Leetcode66》加一（数组表示的数加一。注意进位问题，如果最高位也需要进位，说明原数是999……99，在递归的过程中其实已经把所有位的设为了0，因此只需要将最高位设为1，再pushback一个0即可）
- 《Leetcode78》子集（1表示拿，0表示不拿）
- 《Leetcode171》Excel表列序号（26进制的表示法，注意没有0）
- 《Leetcode190》颠倒二进制位（左移、或、右移）

#### 倍数约数

- 《Leetcode412》Fizz Buzz（同时是m和n的，则求其最小公倍数）

#### 次方与小数

- 《剑指16》数值的整数次方
  - 《Leetcode50》Pow(x, n) （将n转换成二进制进行计算。需要注意：1.x为0时；2.double等于0的判断；3.n取INT_MIN时）
- 《Leetcode69》x的平方根（二分法）
- 《Leetcode166》分数到小数（哈希。未看完）











---

- 《Leetcode55》跳跃游戏（判断是否能跳跃到数组的最右端，贪心算法，使用一个reach值）
- 《Leetcode45》跳跃游戏II（计算跳跃到数组最右端的最少跳跃次数，1.动态规划；2.贪心算法，考虑两步跳跃的范围）