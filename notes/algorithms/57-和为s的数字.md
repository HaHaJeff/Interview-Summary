# 57-和为s的数字

牛客网上有两道这样的题目，一道为“和为S的两个数字”，另一道为“和为S的连续正数序列”，下面分别分析这两道题的解法。

### 和为S的两个数字 

#### 题目描述

输入一个递增排序的数组和一个数字S，在数组中查找两个数，他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

---

### 和为S的连续正数序列

**思路分析**

-	1.使用两个变量head、tail，分别指向数组的第一个数和最后一个数，由于该数组是递增排序的，那么这两个变量就分别指向了数组的最小值和最大值
-	2.将下标为head的数与下标为tail的数相加
	-	如果和等于s，生成数组对保存下来	
	-	如果和小于s，则head++，以获得一个更大的和
	-	如果和大于s，则tail--，以获得一个较小的和
-	3.重复2，直至head>=tail

**我的实现**

```c
class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) {
        int sz = array.size();
        vector<int> result;
        if( sz < 2 ||  array[0] >= sum )
            return result;
        vector<vector<int>> results;
        int head = 0;
        int tail = sz - 1;
        while( head < tail )
        {
            int currentSum = array[head] + array[tail];
            if( currentSum == sum )
            {
                vector<int> temp;
                temp.push_back(array[head]);
                temp.push_back(array[tail]);
                results.push_back(temp);
                head++;
                tail--;
            }else if( currentSum < sum )
            {
                head++;
            }else
            {
                tail--;
            }
        }
        int minProduct = 0x7fffffff; 
        for( int i = 0 ; i < results.size(); i++)
        {
            vector<int> temp = results[i];
            int tempProdoct = temp[0] * temp[1];
            if( tempProdoct < minProduct )
            {
                minProduct = tempProdoct;
                result = results[i];
            }
        }
        
        return result;
    }
};
```


**反思**

在最初实现的时候，最后一部分我是这样实现的

```
		int minProduct = 0x7fffffff; 
		int minIndex = 0;
        for( int i = 0 ; i < results.size(); i++)
        {
            vector<int> temp = results[i];
            int tempProdoct = temp[0] * temp[1];
            if( tempProdoct < minProduct )
            {
                minProduct = tempProdoct;
                minIndex = i;
            }
        }
        
        return results[i];
```

这样实现存在一个问题，如果`results.size()==0`，则`return results[0]`会出错，这里漏掉了数组越界的分析。

**改进**

-	head与tail越远越小，而无需将所有的答案存起来再进行比较。
-	证明：

```
1. head < tail
2. tail - head < 0
3. head + tail = sum
4. (head + n) + (tail - n) = sum
5. (head + n) * (tail - n) = head*tail + n*(tail - head) > head*tail
```

所以代码可以改为：

```
class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) {
        int sz = array.size();
        vector<int> result;
        if( sz < 2 ||  array[0] >= sum )
            return result;
        int head = 0;
        int tail = sz - 1;
        while( head < tail )
        {
            int currentSum = array[head] + array[tail];
            if( currentSum == sum )
            {
                result.push_back(array[head]);
                result.push_back(array[tail]);
                break;
            }else if( currentSum < sum )
            {
                head++;
            }else
            {
                tail--;
            }
        }
        return result;
    }
};
```

时间复杂度：O(n)，空间复杂度O(1)。


