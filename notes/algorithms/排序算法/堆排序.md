# 堆排序

两步：

- 1.建立一个最大堆
- 2.每次将堆顶元素放与堆尾元素交换，然后再重新建堆

时间复杂度O（nlogn)

```c++
void percDown(vector<int>& nums, int index, int N)
{
	//int N = nums.size()-1;
	int tempIndex = index;
	int target = nums[index];
	while (2 * tempIndex + 1 <= N)
	{
		int smallChild = 0;
		if (2 * tempIndex + 2 <= N)
			smallChild = nums[2 * tempIndex + 1] > nums[2 * tempIndex + 2] ? 2 * tempIndex + 1 : 2 * tempIndex + 2;
		else
			smallChild = 2 * tempIndex + 1;
		if (target < nums[smallChild])
			swap(nums[tempIndex], nums[smallChild]);
		else
		{
			nums[tempIndex] = target;
			break;
		}
		tempIndex = smallChild;
	}
}
void heapSort(vector<int>& nums)
{
	int  N = nums.size() - 1;
	for (int i = N / 2 - 1; i >= 0; --i)
		percDown(nums, i, N);
	for (int i = N; i >= 0; --i)
	{
		swap(nums[0], nums[i]);
		percDown(nums, 0, i-1);
	}
}
```

