## 6.3 临时性对象

临时对象的分析，需要考虑三种情况：

```c++
//情况1
T c = a + b;
//情况2
c = a + b;
//情况3
a + b;
```

**情况1**：`T c = a + b;`

有三种方式：

- 方式一：
  - 产生一个临时性对象，放置a+b的结果
  - 使用T的拷贝构造函数把临时性对象当做c的初始值
- 方式二：
  - 不需要临时性对象，以及临时性对象构造函数和析构函数的调用
  - 以拷贝构造的方式，将a+b的值放到c中（2.3节加法运算符的转换曾有讨论）
- 方式三：
  - 视operator+()而定
  - 如果operator+()实施NRV优化，将直接在c中求表达式结果，避免执行c的拷贝构造函数和临时性对象的析构函数

由于C++标准允许编译器厂商对于临时性对象的产生有完全的自由度，为了市场竞争，**情况1**中的表达式几乎不会产生一个临时性对象

**情况2**：`c = a + b;`

情况2中的临时性对象不能被忽略

```c++
c = a + b;
//编译器的行为
T temp;
temp.operator+(a,b);
c.operator=(temp);//将临时对象赋值到c中
temp.T::~T();//析构临时性对象
```

情况2是不能将c直接传递给`operator+`运算符操作，因为`operator+`并不会调用c对象的析构函数，而`operator=`会先调用析构函数，后调用拷贝构造函数。我们是希望将临时性对象赋值给一块新鲜的内存

所以类似于`c = a+b;`这种语句是不安全的，并且会产生很多临时性对象，所以我们建议使用更有效率的初始化语句: 

`T c = a+b;`

**情况3**：`a + b;` 

没有目标对象，有必要产生一个临时对象以放置运算后的结果

该情况下，需要考虑**临时性对象的生命周期**问题（即临时性对象的析构函数什么时候调用）

- 1.对于产生临时对象的完整表达式，临时对象的摧毁应该是对完整表达式求值过程中的最后一个步骤
  - 如`?:`语句，任何一个子表达式产生的任何一个临时对象，都应该在完整表达式求值完成后，才可以毁去
- 2.凡持有表达式执行结果的临时性对象，应该保留到对象的初始化操作完成为止

```c++
bool verbose;
...
String progNameVersion = !verbose ? 0 : progName + progVersion;
//如果在完整的”? : 表达式“结束后就销毁临时的progName + progVersion对象，那么就无法正确初始化progNameVersion
```

- 3.如果一个临时性对象被绑定在一个引用或指针，临时性对象将保留，直到指针和引用的生命周期结束

```c++
const char *progNameVersion = progName + progVersion;
```







